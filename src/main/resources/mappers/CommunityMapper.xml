<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
    "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.community.mapper.CommunityMapper">

    <select id="findAllPosts" resultType="com.community.dto.response.PostResponse">
        SELECT 
            p.id,
            p.title,
            p.content,
            p.author_id as authorId,
            u.nickname as authorNickname,
            p.created_at as createdAt,
            p.updated_at as updatedAt,
            NVL(l.like_count, 0) as likeCount,
            NVL(c.comment_count, 0) as commentCount,
            (
                SELECT LISTAGG('/api/posts/images/' || pf.id, ',') WITHIN GROUP (ORDER BY pf.id)
                FROM post_files pf
                WHERE pf.post_id = p.id
            ) as imageUrls,
            CASE WHEN u.role = 'ADMIN' THEN 1 ELSE 0 END as isAdminPost
        FROM posts p 
        JOIN users u ON p.author_id = u.id
        LEFT JOIN (
            SELECT post_id, COUNT(*) as like_count 
            FROM likes 
            GROUP BY post_id
        ) l ON p.id = l.post_id
        LEFT JOIN (
            SELECT post_id, COUNT(*) as comment_count 
            FROM comments 
            GROUP BY post_id
        ) c ON p.id = c.post_id
        ORDER BY 
            CASE WHEN u.role = 'ADMIN' THEN 0 ELSE 1 END,
            p.created_at DESC
        OFFSET #{offset} ROWS FETCH NEXT #{size} ROWS ONLY
    </select>

    <select id="getTotalPostCount" resultType="int">
        SELECT COUNT(*) FROM posts
    </select>

    <delete id="deletePost">
        DELETE FROM posts WHERE id = #{id}
    </delete>

    <delete id="deleteComment">
        DELETE FROM comments WHERE id = #{id}
    </delete>

    <select id="findUserByEmail" resultType="com.community.dto.response.UserResponse">
        SELECT 
            id, 
            email, 
            department, 
            job_position as jobPosition, 
            nickname, 
            role,
            company,
            created_at as createdAt,
            updated_at as updatedAt
        FROM users WHERE email = #{email}
    </select>

    <select id="findPasswordByEmail" resultType="String">
        SELECT password FROM users WHERE email = #{email}
    </select>

    <select id="findIdByEmail" resultType="Long">
        SELECT id FROM users WHERE email = #{email}
    </select>

    <select id="isAdmin" resultType="boolean">
        SELECT CASE WHEN role = 'ADMIN' THEN 1 ELSE 0 END FROM users WHERE id = #{userId}
    </select>

    <select id="findAllUsers" resultType="com.community.dto.response.UserResponse">
        SELECT 
            id, 
            email, 
            department, 
            job_position as jobPosition, 
            nickname, 
            role,
            company,
            created_at as createdAt,
            updated_at as updatedAt
        FROM users ORDER BY created_at DESC
    </select>

    <select id="findUserById" resultType="com.community.dto.response.UserResponse">
        SELECT 
            id, 
            email, 
            department, 
            job_position as jobPosition, 
            nickname, 
            role,
            company,
            created_at as createdAt,
            updated_at as updatedAt
        FROM users WHERE id = #{id}
    </select>

    <select id="existsByNickname" resultType="boolean">
        SELECT CASE WHEN COUNT(*) > 0 THEN 1 ELSE 0 END FROM users WHERE nickname = #{nickname}
    </select>

    <update id="updateUser">
        UPDATE users SET 
            department = #{department}, 
            job_position = #{jobPosition}, 
            nickname = #{nickname},
            company = #{company},
            updated_at = SYSDATE
        WHERE id = #{id}
    </update>

    <update id="updatePassword">
        UPDATE users SET password = #{newPassword}, updated_at = SYSDATE WHERE id = #{id}
    </update>

    <select id="existsByEmail" resultType="boolean">
        SELECT CASE WHEN COUNT(*) > 0 THEN 1 ELSE 0 END FROM users WHERE email = #{email}
    </select>

    <insert id="insertUser">
        INSERT INTO users (id, email, password, department, job_position, nickname, company, role, created_at, updated_at)
        VALUES ((SELECT NVL(MAX(id),0)+1 FROM users), #{email}, #{password}, #{department}, #{jobPosition}, #{nickname}, #{company}, 'USER', SYSDATE, SYSDATE)
    </insert>

    <select id="findBookmarkedPostIdsByUserId" resultType="Long">
        SELECT post_id FROM bookmarks WHERE user_id = #{userId}
    </select>

    <select id="isBookmarked" resultType="boolean">
        SELECT CASE WHEN COUNT(*) > 0 THEN 1 ELSE 0 END FROM bookmarks WHERE user_id = #{userId} AND post_id = #{postId}
    </select>

    <insert id="addBookmark">
        INSERT INTO bookmarks (id, user_id, post_id, created_at) 
        VALUES ((SELECT NVL(MAX(id),0)+1 FROM bookmarks), #{userId}, #{postId}, SYSDATE)
    </insert>

    <delete id="removeBookmark">
        DELETE FROM bookmarks WHERE user_id = #{userId} AND post_id = #{postId}
    </delete>

    <update id="toggleBookmark" parameterType="map">
        DECLARE
            v_count NUMBER;
        BEGIN
            SELECT COUNT(*) INTO v_count FROM bookmarks WHERE user_id = #{userId} AND post_id = #{postId};
            
            IF v_count > 0 THEN
                DELETE FROM bookmarks WHERE user_id = #{userId} AND post_id = #{postId};
            ELSE
                INSERT INTO bookmarks (id, user_id, post_id, created_at) 
                VALUES ((SELECT NVL(MAX(id),0)+1 FROM bookmarks), #{userId}, #{postId}, SYSDATE);
            END IF;
        END;
    </update>

    <select id="findCommentsByPostId" resultType="com.community.dto.response.CommentResponse">
        SELECT 
            c.id,
            c.content,
            c.author_id as authorId,
            u.nickname as authorNickname,
            c.post_id as postId,
            c.parent_id as parentId,
            c.created_at as createdAt,
            c.updated_at as updatedAt
        FROM comments c 
        JOIN users u ON c.author_id = u.id
        WHERE c.post_id = #{postId}
        ORDER BY c.created_at ASC
    </select>

    <insert id="insertComment" useGeneratedKeys="true" keyProperty="id" keyColumn="id">
        <selectKey keyProperty="id" resultType="Long" order="BEFORE">
            SELECT NVL(MAX(id),0)+1 FROM comments
        </selectKey>
        INSERT INTO comments (id, content, post_id, author_id, parent_id, created_at, updated_at)
        VALUES (#{id}, #{content}, #{postId}, #{userId}, #{parentId, jdbcType=BIGINT}, SYSDATE, SYSDATE)
    </insert>

    <select id="findCommentById" resultType="com.community.dto.response.CommentResponse">
        SELECT 
            c.id,
            c.content,
            c.author_id as authorId,
            u.nickname as authorNickname,
            c.post_id as postId,
            c.parent_id as parentId,
            c.created_at as createdAt,
            c.updated_at as updatedAt
        FROM comments c 
        JOIN users u ON c.author_id = u.id
        WHERE c.id = #{id}
    </select>

    <select id="isCommentAuthor" resultType="boolean">
        SELECT CASE WHEN COUNT(*) > 0 THEN 1 ELSE 0 END FROM comments WHERE id = #{id} AND author_id = #{userId}
    </select>

    <update id="updateComment">
        UPDATE comments SET content = #{content}, updated_at = SYSDATE WHERE id = #{id}
    </update>

    <insert id="insertPostFile" parameterType="map">
        <selectKey keyProperty="id" resultType="Long" order="BEFORE">
            SELECT NVL(MAX(id),0)+1 FROM post_files
        </selectKey>
        INSERT INTO post_files (id, post_id, original_name, filename, file_path, stored_filename, file_data, file_size, content_type, created_at)
        VALUES (#{id}, #{postId}, #{originalFileName}, #{storedFileName}, 'uploads/', #{storedFileName}, #{fileData}, #{size}, #{contentType}, SYSDATE)
    </insert>

    <select id="getFileData" resultType="java.util.HashMap">
        SELECT 
            file_data as "fileData", 
            content_type as "contentType" 
        FROM post_files 
        WHERE id = #{fileId}
    </select>

    <select id="findLikesByPostId" resultType="com.community.dto.response.LikeResponse">
        SELECT id, user_id as userId, post_id as postId, created_at as createdAt 
        FROM likes WHERE post_id = #{postId}
    </select>

    <select id="findLikesByUserId" resultType="com.community.dto.response.LikeResponse">
        SELECT id, user_id as userId, post_id as postId, created_at as createdAt 
        FROM likes WHERE user_id = #{userId}
    </select>

    <select id="isLiked" resultType="boolean">
        SELECT CASE WHEN COUNT(*) > 0 THEN 1 ELSE 0 END FROM likes WHERE user_id = #{userId} AND post_id = #{postId}
    </select>

    <select id="getLikeCount" resultType="int">
        SELECT COUNT(*) FROM likes WHERE post_id = #{postId}
    </select>

    <insert id="addLike">
        INSERT INTO likes (id, user_id, post_id, created_at) 
        VALUES ((SELECT NVL(MAX(id),0)+1 FROM likes), #{userId}, #{postId}, SYSDATE)
    </insert>

    <delete id="removeLike">
        DELETE FROM likes WHERE user_id = #{userId} AND post_id = #{postId}
    </delete>

    <update id="toggleLike" parameterType="map">
        DECLARE
            v_count NUMBER;
        BEGIN
            SELECT COUNT(*) INTO v_count FROM likes WHERE user_id = #{userId} AND post_id = #{postId};
            
            IF v_count > 0 THEN
                DELETE FROM likes WHERE user_id = #{userId} AND post_id = #{postId};
            ELSE
                INSERT INTO likes (id, user_id, post_id, created_at) 
                VALUES ((SELECT NVL(MAX(id),0)+1 FROM likes), #{userId}, #{postId}, SYSDATE);
            END IF;
        END;
    </update>

    <select id="getReceivedMessages" resultType="com.community.dto.response.MessageResponse">
        SELECT 
            m.id,
            m.title,
            m.content,
            m.sender_id as senderId,
            u1.nickname as senderName,
            m.receiver_id as receiverId,
            u2.nickname as receiverName,
            m.is_read as isRead,
            m.deleted_by_sender as deletedBySender,
            m.deleted_by_receiver as deletedByReceiver,
            m.created_at as createdAt,
            m.read_at as readAt
        FROM messages m
        JOIN users u1 ON m.sender_id = u1.id
        JOIN users u2 ON m.receiver_id = u2.id
        WHERE m.receiver_id = #{userId} AND (m.deleted_by_receiver = 0 OR m.deleted_by_receiver IS NULL)
        ORDER BY m.created_at DESC
    </select>

    <select id="getSentMessages" resultType="com.community.dto.response.MessageResponse">
        SELECT 
            m.id,
            m.title,
            m.content,
            m.sender_id as senderId,
            u1.nickname as senderName,
            m.receiver_id as receiverId,
            u2.nickname as receiverName,
            m.is_read as isRead,
            m.deleted_by_sender as deletedBySender,
            m.deleted_by_receiver as deletedByReceiver,
            m.created_at as createdAt,
            m.read_at as readAt
        FROM messages m
        JOIN users u1 ON m.sender_id = u1.id
        JOIN users u2 ON m.receiver_id = u2.id
        WHERE m.sender_id = #{userId} AND (m.deleted_by_sender = 0 OR m.deleted_by_sender IS NULL)
        ORDER BY m.created_at DESC
    </select>

    <select id="getMessageById" resultType="com.community.dto.response.MessageResponse">
        SELECT 
            m.id,
            m.title,
            m.content,
            m.sender_id as senderId,
            u1.nickname as senderName,
            m.receiver_id as receiverId,
            u2.nickname as receiverName,
            m.is_read as isRead,
            m.deleted_by_sender as deletedBySender,
            m.deleted_by_receiver as deletedByReceiver,
            m.created_at as createdAt,
            m.read_at as readAt
        FROM messages m
        JOIN users u1 ON m.sender_id = u1.id
        JOIN users u2 ON m.receiver_id = u2.id
        WHERE m.id = #{id}
    </select>

    <insert id="createMessage" useGeneratedKeys="true" keyProperty="id" keyColumn="id">
        <selectKey keyProperty="id" resultType="Long" order="BEFORE">
            SELECT NVL(MAX(id),0)+1 FROM messages
        </selectKey>
        INSERT INTO messages (id, title, content, sender_id, receiver_id, is_read, deleted_by_sender, deleted_by_receiver, created_at)
        VALUES (#{id}, #{request.title}, #{request.content}, #{senderId}, #{request.receiverId}, 0, 0, 0, SYSDATE)
    </insert>

    <update id="markAsRead">
        UPDATE messages SET is_read = 1, read_at = SYSDATE WHERE id = #{id}
    </update>

    <update id="deleteByReceiver">
        UPDATE messages SET deleted_by_receiver = 1 WHERE id = #{id}
    </update>

    <update id="deleteBySender">
        UPDATE messages SET deleted_by_sender = 1 WHERE id = #{id}
    </update>

    <select id="findPostById" resultType="com.community.dto.response.PostResponse">
        SELECT 
            p.id,
            p.title,
            p.content,
            p.author_id as authorId,
            u.nickname as authorNickname,
            p.created_at as createdAt,
            p.updated_at as updatedAt,
            NVL(l.like_count, 0) as likeCount,
            NVL(c.comment_count, 0) as commentCount,
            (
                SELECT LISTAGG('/api/posts/images/' || pf.id, ',') WITHIN GROUP (ORDER BY pf.id)
                FROM post_files pf
                WHERE pf.post_id = p.id
            ) as imageUrls,
            CASE WHEN u.role = 'ADMIN' THEN 1 ELSE 0 END as isAdminPost
        FROM posts p 
        JOIN users u ON p.author_id = u.id
        LEFT JOIN (
            SELECT post_id, COUNT(*) as like_count 
            FROM likes 
            GROUP BY post_id
        ) l ON p.id = l.post_id
        LEFT JOIN (
            SELECT post_id, COUNT(*) as comment_count 
            FROM comments 
            GROUP BY post_id
        ) c ON p.id = c.post_id
        WHERE p.id = #{id}
    </select>

    <insert id="insertPost" parameterType="map">
        <selectKey keyProperty="id" resultType="Long" order="BEFORE">
            SELECT NVL(MAX(id),0)+1 FROM posts
        </selectKey>
        INSERT INTO posts (id, title, content, author_id, like_count, comment_count, created_at, updated_at)
        VALUES (#{id}, #{title}, #{content}, #{userId}, 0, 0, SYSDATE, SYSDATE)
    </insert>

    <select id="isPostAuthor" resultType="boolean">
        SELECT CASE WHEN COUNT(*) > 0 THEN 1 ELSE 0 END FROM posts WHERE id = #{id} AND author_id = #{userId}
    </select>

    <update id="updatePost" parameterType="map">
        UPDATE posts SET title = #{title}, content = #{content}, updated_at = SYSDATE WHERE id = #{id}
    </update>

    <select id="findPostsByAuthorId" resultType="com.community.dto.response.PostResponse">
        SELECT 
            p.id,
            p.title,
            p.content,
            p.author_id as authorId,
            u.nickname as authorNickname,
            p.created_at as createdAt,
            p.updated_at as updatedAt,
            NVL(l.like_count, 0) as likeCount,
            NVL(c.comment_count, 0) as commentCount,
            (
                SELECT LISTAGG('/api/posts/images/' || pf.id, ',') WITHIN GROUP (ORDER BY pf.id)
                FROM post_files pf
                WHERE pf.post_id = p.id
            ) as imageUrls,
            CASE WHEN u.role = 'ADMIN' THEN 1 ELSE 0 END as isAdminPost
        FROM posts p 
        JOIN users u ON p.author_id = u.id
        LEFT JOIN (
            SELECT post_id, COUNT(*) as like_count 
            FROM likes 
            GROUP BY post_id
        ) l ON p.id = l.post_id
        LEFT JOIN (
            SELECT post_id, COUNT(*) as comment_count 
            FROM comments 
            GROUP BY post_id
        ) c ON p.id = c.post_id
        WHERE p.author_id = #{userId}
        ORDER BY CASE WHEN u.role = 'ADMIN' THEN 0 ELSE 1 END, p.created_at DESC
        OFFSET #{offset} ROWS FETCH NEXT #{size} ROWS ONLY
    </select>

    <select id="getPostCountByAuthorId" resultType="int">
        SELECT COUNT(*) FROM posts WHERE author_id = #{userId}
    </select>
    
    <select id="findAllComments" resultType="com.community.dto.response.CommentResponse">
        SELECT 
            c.id,
            c.content,
            c.author_id as authorId,
            u.nickname as authorNickname,
            c.post_id as postId,
            p.title as postTitle,
            c.parent_id as parentId,
            c.created_at as createdAt,
            c.updated_at as updatedAt
        FROM comments c 
        JOIN users u ON c.author_id = u.id
        JOIN posts p ON c.post_id = p.id
        ORDER BY c.created_at DESC
        OFFSET #{offset} ROWS FETCH NEXT #{size} ROWS ONLY
    </select>

    <select id="getTotalCommentCount" resultType="int">
        SELECT COUNT(*) FROM comments
    </select>
    
    <select id="searchPosts" resultType="com.community.dto.response.PostResponse">
        SELECT 
            p.id,
            p.title,
            p.content,
            p.author_id as authorId,
            u.nickname as authorNickname,
            p.created_at as createdAt,
            p.updated_at as updatedAt,
            NVL(l.like_count, 0) as likeCount,
            NVL(c.comment_count, 0) as commentCount,
            (
                SELECT LISTAGG('/api/posts/images/' || pf.id, ',') WITHIN GROUP (ORDER BY pf.id)
                FROM post_files pf
                WHERE pf.post_id = p.id
            ) as imageUrls,
            CASE WHEN u.role = 'ADMIN' THEN 1 ELSE 0 END as isAdminPost
        FROM posts p 
        JOIN users u ON p.author_id = u.id
        LEFT JOIN (
            SELECT post_id, COUNT(*) as like_count 
            FROM likes 
            GROUP BY post_id
        ) l ON p.id = l.post_id
        LEFT JOIN (
            SELECT post_id, COUNT(*) as comment_count 
            FROM comments 
            GROUP BY post_id
        ) c ON p.id = c.post_id
        WHERE (UPPER(p.title) LIKE UPPER('%' || #{keyword} || '%') 
               OR UPPER(p.content) LIKE UPPER('%' || #{keyword} || '%')
               OR UPPER(u.nickname) LIKE UPPER('%' || #{keyword} || '%'))
        ORDER BY 
            CASE WHEN u.role = 'ADMIN' THEN 0 ELSE 1 END,
            p.created_at DESC
        OFFSET #{offset} ROWS FETCH NEXT #{size} ROWS ONLY
    </select>

    <select id="getSearchPostCount" resultType="int">
        SELECT COUNT(*) 
        FROM posts p 
        JOIN users u ON p.author_id = u.id
        WHERE (UPPER(p.title) LIKE UPPER('%' || #{keyword} || '%') 
               OR UPPER(p.content) LIKE UPPER('%' || #{keyword} || '%')
               OR UPPER(u.nickname) LIKE UPPER('%' || #{keyword} || '%'))
    </select>

    <select id="searchUsers" resultType="com.community.dto.response.UserResponse">
        SELECT 
            id, 
            email, 
            department, 
            job_position as jobPosition, 
            nickname, 
            role,
            company,
            created_at as createdAt,
            updated_at as updatedAt
        FROM users 
        WHERE (UPPER(email) LIKE UPPER('%' || #{keyword} || '%')
               OR UPPER(nickname) LIKE UPPER('%' || #{keyword} || '%')
               OR UPPER(department) LIKE UPPER('%' || #{keyword} || '%')
               OR UPPER(job_position) LIKE UPPER('%' || #{keyword} || '%')
               OR UPPER(company) LIKE UPPER('%' || #{keyword} || '%'))
        ORDER BY created_at DESC
    </select>

    <select id="searchComments" resultType="com.community.dto.response.CommentResponse">
        SELECT 
            c.id,
            c.content,
            c.author_id as authorId,
            u.nickname as authorNickname,
            c.post_id as postId,
            p.title as postTitle,
            c.parent_id as parentId,
            c.created_at as createdAt,
            c.updated_at as updatedAt
        FROM comments c 
        JOIN users u ON c.author_id = u.id
        JOIN posts p ON c.post_id = p.id
        WHERE (UPPER(c.content) LIKE UPPER('%' || #{keyword} || '%')
               OR UPPER(u.nickname) LIKE UPPER('%' || #{keyword} || '%'))
        ORDER BY c.created_at DESC
        OFFSET #{offset} ROWS FETCH NEXT #{size} ROWS ONLY
    </select>

    <select id="getSearchCommentCount" resultType="int">
        SELECT COUNT(*) 
        FROM comments c 
        JOIN users u ON c.author_id = u.id
        WHERE (UPPER(c.content) LIKE UPPER('%' || #{keyword} || '%')
               OR UPPER(u.nickname) LIKE UPPER('%' || #{keyword} || '%'))
    </select>

</mapper>